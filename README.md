# METARESC: META data and RESource library for C language

[![YourActionName Actions Status](https://github.com/alexanderchuranov/Metaresc/workflows/ci/badge.svg)](https://github.com/alexanderchuranov/Metaresc/actions)

METARESC is a software library written in the C programming language. It
allows declaring types using a special METARESC grammar. The variables
of types declared that way may be subsequently serialized into various
formats and deserialized later. To achieve this the library adds
metadata annotations to types. These annotations may be used for may
purposes far beyond just achieving the persistence.

## How to build:

Install external dependencies `autoconf`, `automake`, `libtool`, `pkg-config`, `flex`, `bison`, `libxml2-dev`, `check`, `libdwarf-dev`.
Clone Metaresc from the Github, configure and build according to the standard autoconf/automake process.

### Ubuntu

On Ubuntu, run the following command:

```console
# apt-get install git autoconf automake libtool pkg-config flex bison libxml2-dev check libdwarf-dev
```

Checkout Metaresc from github

```console
$ git clone https://github.com/alexanderchuranov/Metaresc.git
```

Run autoconf/automake generators:

```console
$ ./autogen.sh
```

Configure project for target system

```console
$ ./configure
```

Build and check library

```console
$ make -j 4 check
```
### MacOs

On Big Sur install developer tools first:

```console
$ xcode-select --install
```

Install external dependencies:
```console
# brew install autoconf automake libtool pkg-config flex bison libxml2 check
```

For DWARF (debug info format) support install libdwarf:

```console
$ git clone git://git.code.sf.net/p/libdwarf/code libdwarf-code
$ cd libdwarf-code
$ sh scripts/FIX-CONFIGURE-TIMES
$ ./configure
$ make
# make install
```

Checkout and build Metaresc:

```console
$ git clone https://github.com/alexanderchuranov/Metaresc.git
$ cd Metaresc
$ ./autogen.sh
$ ./configure HAVE_BISON=yes YACC=/usr/local/opt/bison/bin/bison LIBS="-lz -ll"
$ make -j 4 check
```

### FreeBSD

On FreeBSD 12.1 install external dependencies:
```console
# pkg install git autoconf automake libtool pkgconf flex bison libxml2 check libdwarf 
```

Checkout and build Metaresc:

```console
$ git clone https://github.com/alexanderchuranov/Metaresc.git
$ cd Metaresc
$ ./autogen.sh
$ ./configure
$ make -j 4 check
```

### Windows

On Windows one can use MinGW

* Download MinGW installer from here: https://sourceforge.net/projects/mingw/files/latest/download
* Choose Basic Setup > mingw-developer-toolkit && mingw32-base

Also:

* You will need Bison v 3+ and `pkg-config`.
* Download Bison and Flex from here: https://sourceforge.net/projects/winflexbison/files/latest/download
* Extract archive to user home dir in MSYS: `c:\MinGW\msys\1.0\home\UserName\`
* Download `pkg-config` from here: https://sourceforge.net/projects/pkgconfiglite/files/latest/download
* Extract archive to `c:\MinGW`

Optionally you could install `libxml2-dev` and `check`. It should be a similar process with prebuilt binaries.

Having this minimal configuration you could build the library using standard autoconf/automake toolchain. 

Checkout Metaresc from github

```console
$ git clone https://github.com/alexanderchuranov/Metaresc.git
```

Run autoconf/automake generators:

```console
$ ./autogen.sh
```

Configure project for target system

```console
$ ./configure CFLAGS=-D__USE_MINGW_ANSI_STDIO HAVE_BISON=yes HAVE_FLEX=yes YACC=~/win_flex_bison3-latest/win_bison.exe LEX=~/win_flex_bison3-latest/win_flex.exe
```

Build and check library

```console
$ make check
```

## How to build a sample app

Instruction below will cover scenario when Metaresc is build locally
and is not installed into the system.

Create a folder at the same level as Metaresc. Start with hello world
stub that will use `metaresc.h`.

```c
#include <stdio.h>
#include <stdlib.h>

#include <metaresc.h>
  
int main (int argc, char * argv[])
{
  printf ("Hello world!\n");
  return (EXIT_SUCCESS);
}
```

Compiler should be instructed where to find Metaresc header file, so
we should add `-I../Metaresc/src` as a compilation flag. Minimal
`Makefile` for this app should be as follows: 

```make
all: sample

CFLAGS += -I../Metaresc/src
```

As a next step we will add some custom structure type definition,
variable of that type and serialization of this variable into format
consumable by C compiler as a static initialization of that type. For
demonstration purposes sample app will define type for the binary tree
node with `char * value`. Metaresc provides two basic layers that
enables reflection in C. First is a macro language that replaces
standard type definition semantics. Second is an API to introspect
meta-data generated by macro language and serialize structures
according to this metadata. Macro language is pretty similar to
standard semantics of types definition in C, but still require some
learning curve. In the following example it should be
self-explanatory.

```c
#include <stdio.h>
#include <stdlib.h>

#include <metaresc.h>

TYPEDEF_STRUCT (tree_node_t,
		(char *, value),
		(tree_node_t *, left),
		(tree_node_t *, right),
		);
  
int main (int argc, char * argv[])
{
  tree_node_t root = {
    "root",
    (tree_node_t[]){ { "left" } },
    (tree_node_t[]){ { "right" } },
  };
  
  char * dump = MR_SAVE_CINIT (tree_node_t, &root);
  if (dump)
    {
      printf ("%s", dump);
      MR_FREE (dump);
    }
  return (EXIT_SUCCESS);
}
```

At this point we need to link our application against statically build
Metaresc library files. `Makefile` should be extended as follows:
```make
all: sample

CFLAGS += -I../Metaresc/src
LDLIBS += ../Metaresc/src/.libs/libmetaresc.a
```

Compilation with Clang will produce a warning about duplicated
'const' specifier: `sample.c:6:1: warning: duplicate 'const'
declaration specifier [-Wduplicate-decl-specifier]` You may suppress
it with the `-Wno-duplicate-decl-specifier` flag. I.e. final `Makefile` is
as follows:

```make
all: sample

CFLAGS += -I../Metaresc/src -Wno-duplicate-decl-specifier
LDLIBS += ../Metaresc/src/.libs/libmetaresc.a
```

Output of this sample application is as follows:
```c
{
  .value = "root",
  .left = (tree_node_t[]){
    {
      .value = "left",
      .left = NULL,
      .right = NULL
    }
  },
  .right = (tree_node_t[]){
    {
      .value = "right",
      .left = NULL,
      .right = NULL
    }
  }
}
```

You may find custom macro language for types definition as an
overkill. In this case you could use Metaresc macro language only for
metadata generation and keep definitions of your types in a plain
C. It basically means that you need duplicate type definition:
once in standard C and one more time with a Metaresc macro
language. In this case global preprocessor variable `MR_MODE` should
be defined into `DESC`. Example above will look as follows:

```c
#include <stdio.h>
#include <stdlib.h>

#include <metaresc.h>

typedef struct tree_node_t {
  char * value;
  struct tree_node_t * left;
  struct tree_node_t * right;
} tree_node_t;

#define MR_MODE DESC
TYPEDEF_STRUCT (tree_node_t,
		(char *, value),
		(tree_node_t *, left),
		(tree_node_t *, right),
		);
  
int main (int argc, char * argv[])
{
  tree_node_t root = {
    "root",
    (tree_node_t[]){ { "left" } },
    (tree_node_t[]){ { "right" } },
  };
  
  char * dump = MR_SAVE_CINIT (tree_node_t, &root);
  if (dump)
    {
      printf ("%s", dump);
      MR_FREE (dump);
    }
  return (EXIT_SUCCESS);
}
```

The good news is that you could omit types specification in macro
language for all fields of basic types (boolean, integer, float,
complex, single characters, strings, pointers on all types listed
above and even pointers on structures of base type). So example above
could be reduced to:
```c
#include <stdio.h>
#include <stdlib.h>

#include <metaresc.h>

typedef struct tree_node_t {
  char * value;
  struct tree_node_t * left;
  struct tree_node_t * right;
} tree_node_t;

#define MR_MODE DESC
TYPEDEF_STRUCT (tree_node_t, value, left, right);
  
int main (int argc, char * argv[])
{
  tree_node_t root = {
    "root",
    (tree_node_t[]){ { "left" } },
    (tree_node_t[]){ { "right" } },
  };
  
  char * dump = MR_SAVE_CINIT (tree_node_t, &root);
  if (dump)
    {
      printf ("%s", dump);
      MR_FREE (dump);
    }
  return (EXIT_SUCCESS);
}
```

I would expect that some of the users still will find this a bit
challenging and overcomplicated. For those users library provides a
way to generate metadata from compiler debug symbols. It adds some
complexity to a build process, but doesn't require any interaction
with a macro language. In this case sample above will look as follows:

```c
#include <stdio.h>
#include <stdlib.h>

#include <metaresc.h>

typedef struct tree_node_t {
  char * value;
  struct tree_node_t * left;
  struct tree_node_t * right;
} tree_node_t;

int main (int argc, char * argv[])
{
  tree_node_t root = {
    "root",
    (tree_node_t[]){ { "left" } },
    (tree_node_t[]){ { "right" } },
  };
  
  char * dump = MR_SAVE_CINIT (tree_node_t, &root);
  if (dump)
    {
      printf ("%s", dump);
      MR_FREE (dump);
    }
  return (EXIT_SUCCESS);
}
```
You need to add one more file to the project `sample_types.c`:

```c
#include <metaresc.h>

mr_td_t mr_td[] = {
#include "sample_types.h"
};

static void __attribute__ ((constructor)) mr_types_init ()
{
  int i;
  for (i = 0; i < sizeof (mr_td) / sizeof (mr_td[0]); ++i)
    mr_add_type (&mr_td[i]);
}
```

`Makefile` should be modified as follows:

```make
all: sample

sample: sample.o sample_types.o
sample_no_types: sample.o
	$(LINK.c) $^ $(LOADLIBES) $(LDLIBS) -o $@
sample_types.o: sample_types.c sample_types.h
sample_types.h: sample_no_types
ifeq ($(shell uname), Darwin)
	dsymutil $?
endif
	../Metaresc/src/mr_dwarf $? > $@

clean:
	$(RM) *.o sample_types.h

CFLAGS += -I../Metaresc/src -Wno-duplicate-decl-specifier -O2 -g -Wall
LDLIBS += ../Metaresc/src/.libs/libmetaresc.a
```

By default library provides serialization/deserialization to/from
following formats:
* CINIT - format consumable by C compiler for static initialization of
corresponding types
* JSON - [JavaScript Object Notation](https://www.json.org/json-en.html)
* XML1 - builtin parser/serializer of XML
* XML2 - interface to libxml2
* SCM - Lisp-like notation
* XDR - binary format for [External Data Representation
Standard](https://tools.ietf.org/html/rfc4506)

## Types definition macro language

Metaresc provides 4 top level macro definitions.
* `TYPEDEF_STRUCT` - equivalent for `typedef struct type_t {} type_t;`
* `TYPEDEF_UNION` - equivalent for `typedef union type_t {} type_t;`
* `TYPEDEF_ENUM` - equivalent for `typedef enum type_t {} type_t;`
* `TYPEDEF_FUNC` - works for definition of function pointer types

### Structures definition
`TYPEDEF_STRUCT` must have at least one argument - struct type name.
All consequent arguments are delimited by comma and considered as a
structure fields declarations. Empty declarations are ignored. Fields
declarations could be presented in a multiple forms:
1. most of the basic types could be declared in a standard C notation
2. pointers, fields of a custom types, arrays, function pointers
should be declared as a structured set in parentheses
3. non-serializable fields, bitfields, anonymous unions looks like a
macro calls, i.e. a `keyword` followed by a set of arguments in parentheses.

#### Fields of a basic types
This is a simplified notation for basic types. It allows declaration
of a **single** field with a type name that consists of the following
keywords:
* `char`
* `short`
* `int`
* `unsigned`
* `signed`
* `long`
* `float`
* `double`
* `bool`
* `_Bool`
* `complex`
* `__complex__`
* `_Complex`
* `int8_t`
* `uint8_t`
* `int16_t`
* `uint16_t`
* `int32_t`
* `uint32_t`
* `int64_t`
* `uint64_t`
* `size_t`
* `ssize_t`
* `long_double_t`
* `string_t`
* `mr_ptr_t`
* `volatile`
* `__volatile`
* `__volatile__`
* `const`
* `__const`
* `__const__`

Here is a valid example:
```c
TYPEDEF_STRUCT (sample_t,
		int x,
		long int y,
		long long int z,
		volatile long long int v,
		);
```

#### Extended semantics for fields declaration
Extended semantics allows not only declaration itself, but also a
metadata definition. User could augment fields with text metadata and
arbitrary structured resources. User could access metadata and
resources at runtime via reflection API provided by Metaresc. Field
declaration is presented as positional set of parameters in
parentheses:

(type, name, _suffix_, _text\_metadata_, _{ pointer\_on\_resources\_array }_, _resource\_type_, _resources\_array\_size_)

Only the first two parameters are mandatory, the rest are optional.
1. **type** is a field type
2. **name** is a field name
3. **_suffix_** is used for declaration of arrays and function pointers
4. **_text\_metadata_** is a user defined string
5. **_pointer\_on\_resources\_array_** is a `void*` pointer that user can \
initialize with a pointer on array of structured resources
6. **_resource\_type_** is a string that defines type of resource pointer
7. **_resource\_array\_size_** is an integer value that denotes size of \
resource array

**_text\_metadata_** and **_resource_** information are available at
  run-time through reflection API.

Example below demonstrates extended semantics:
```c
TYPEDEF_STRUCT (sample_t,
		(int, field),
		(int *, pointer),
		(int, array, [2]),
		(int, function, (int)),
		(int, metadata, /* suffix */, "text metadata"),
		(int, void_resource, /* suffix */, /* text metadata */, { "string as a void pointer" }),
		(int, structured_resource, /* suffix */, /* text metadata */, { (sample_t[]){{0}} }, "sample_t"),
		(int, structured_resources_array, /* suffix */, /* text metadata */, { (sample_t[]){{0}, {1}} }, "sample_t", 2 * sizeof (sample_t)),
		);
```

##### Fields declaration
Type of the field may consist of multiple tokens and could include
keywords: `const`, `volatile`, `restrict`, `struct`, `union`,
`enum`. Name of the field must be strictly one token.

##### Pointer declaration
Metaresc is capable to resolve pointers on basic types and on custom
user's types. `char *` is treated as pointer on a NULL-terminated
string, but not a pointer on a single character.

Double pointers are not supported and user should use intermediate
wrapper structure to represent each level of indirect
access. I.e. `int ** double_pointer` should be declared as follows:

```c
TYPEDEF_STRUCT (int_ptr_t,
		(int *, ptr));

TYPEDEF_STRUCT (sample_t,
		(int_ptr_t *, double_pointer));
```

Default serialization of pointer is a single instance of designated
type, but Metaresc also supports representation of pointers as arrays
of variable size. Size of the array in this case should be another
field of the same structure. User may specify name of
this field via structured resource of the pointer field. There are two
options how to do this.
1. User may specify name of the `size` field as a string and denote 
that type of the resource is a `"string"`. Sample declaration as 
follows:

```c
TYPEDEF_STRUCT (resizable_array_t,
		(sample_t *, array, /* suffix */, /* text metadata */, { "array_size" }, "string"),
		ssize_t array_size,
		);
```
Existence of the `size` field could be validated only at the run-time,
so this method makes a loosely-coupled definition.

2. Another way to specify `size` field is to provide `offset` of this
field as a structured resource. Sample declaration as follows:

```c
TYPEDEF_STRUCT (resizable_array_t,
		(sample_t *, array, /* suffix */, /* text metadata */, { .offset = offsetof (resizable_array_t, array_size) }, "offset"),
		ssize_t array_size,
		);
```
This method ensures that `size` field is presented in
designated structure, but does not verify that `pointer` and `size`
fields are within the same structure and `size` field has appropriate
type. This validation happens at run-time. `size` field might be of
any integer type including `bool` and `char`. It could also be an
`enum` or `bitfield` which are integer types by language design. `size`
field could also be a pointer on any type listed above except
`bitfield`. `bitfields` could be specified as `size` field only with
the first declaration method, because compiler can't calculate
`offsetof` for the `bitfields`.

Descriptors for pointer fields that are generated from DWARF debug
info have structured resource configured according to the first
method. I.e. `size` field configured as a string identifier and formed
from the name of the field with `_size` suffix.

##### Arrays declaration
Third argument `suffix` in the field's declaration denotes dimensions
of the array. Metaresc is capable to distinguish one- and two-
dimensional arrays. Higher orders of dimensions are treated as
two-dimensional arrays with aggregated lower dimension. User should
use intermediate wrapper types for propper serialization of 3+
dimensional arrays.

```c
TYPEDEF_STRUCT (array_1d_t,
		(int, array, [2]));
TYPEDEF_STRUCT (array_2d_t,
		(int, array, [2][2]));
TYPEDEF_STRUCT (array_3d_t,
		(array_1d_t, array, [2][2]));
TYPEDEF_STRUCT (_array_3d_t,
		(array_2d_t, array, [2]));
TYPEDEF_STRUCT (array_4d_t,
		(array_2d_t, array, [2][2]));
```

Zero-size arrays are also supported. Type descriptor will have all
meta information for those fields, but serializaiton will omit them as
empty fields. C standard allows empty-size declaration at the end of
the structure. In Metaresc those fields could be declared as
non-serializable.

```c
TYPEDEF_STRUCT (array_t,
		(int, zero_size_array, [0]),
		VOID (int, empty_size_array, []));
```

##### Function pointers declaration
If `suffix` is an expression in parentheses, then this field is
treated as a function pointer declaration. I.e. declaration is
equivalent of `type (*name) suffix;` as a standard type
declaration. List of function agruments is processed and Metaresc type
descriptor contains this list in a structured way. This information
could be retrieved at run-time trhough reflection API. User must not
use arguments names in this declaration. Variadic functions should be
declared as non-serializable fields. Metaresc serialize function
pointers as function names retrieved via `dladdr ()`. If function name
is not available then pointer is serialized as hex value.

```c
TYPEDEF_STRUCT (functions_t,
		(int, my_fork, ()),
		(int, my_fork_implicit_void, (void)),
		(int, my_vprintf, (const char * restrict /* format */, va_list /* ap */)),
		VOID (int, (*my_printf), (const char * restrict /* format */, ...)),
		);
```

##### Text metadata and resource information
Text metadata is a user defined string that could be retrieved at
run-time through reflection API. This property is also used for union
fields discrimination (a way to identify at run-time which union field
to use).

Resource information (_text\_metadata_, _{
pointer\_on\_resources\_array }_, _resource\_type_,
_resources\_array\_size_) is also available at run-time through
reflection API and is used for dynamic arrays size specification.
